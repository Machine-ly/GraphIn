{"version":3,"sources":["components/Graph/Node/Node.module.css","components/Board/Board.module.css","components/Graph/Graph.module.css","assets/js/calc.js","components/Graph/Node/Node.jsx","data-structures/Queue.js","data-structures/Stack.js","algorithms/algorithms.js","assets/js/readOnly.js","components/Graph/Graph.jsx","components/Board/Board.jsx","App.jsx","index.js"],"names":["module","exports","calculateAccurateCoords","x1","y1","x2","y2","distance","Math","sqrt","ratio","tempX","tempY","doesPointLieOnCircle","centerX","centerY","radius","pointX","pointY","pow","Node","props","node","edges","handleMove","handleEdge","editEdgeMode","readyForVisualization","readyForMovement","readyForEdge","pathFindingNode","className","styles","nodeGroup","onPointerDown","isVisited","visited","isInShortestPath","shortestPath","startNodeId","id","startNode","endNodeId","endNode","cx","x","cy","y","r","toString","get","map","edge","directedPath","mpx","mpy","theta","atan2","PI","c1x","cos","c1y","sin","calculateCurve","undirectedPath","textCoordDirected","calculateTextLoc","type","arrow","isUsedInTraversal","arrowTraversal","isUsedInShortestPath","arrowShortestPath","to","markerWidth","markerHeight","refX","refY","orient","points","onClick","d","directedEdge","disableEdge","usedInTraversal","usedInShortestPath","markerEnd","weight","edgeText","undirectedEdge","nodeX2","nodeY2","nodeText","Queue","this","queue","item","push","isEmpty","length","shift","Stack","stack","pop","backtrack","prev","mockEdge","NaN","from","visitedOrder","visitedEdges","currentNodeId","has","reverse","i","getSmallestUnvisited","unvisitedSet","smallestUnvisited","forEach","_value","parseInt","sort","a","b","getUnvisitedNeighbours","currentEdge","shouldCompare","newDistance","value","d_edge","Infinity","set","findNeighbours","nodeId","visitedSet","add","edgeOptions","key","text","algoOptions","itemType","DropdownMenuItemType","Divider","Header","data","algoMessages","traversal","bfs","info","dfs","pathfinding","dijkstra","failure","Graph","options","selectedEdge","selectedAlgo","visualizationSpeed","setVisualizingState","setNodeSelection","nodeSelection","isVisualizing","useState","nodes","setNodes","Map","setEdges","isModalOpen","setModalState","setEdge","setPathFindingNode","isPathPossible","setPathPossible","setMockEdge","currentNode","useRef","nodesTillNow","graph","isVisualizationDone","resetNodesAndEdgesState","useCallback","updateNodes","updatedEdges","cloneDeep","list","newList","current","useEffect","addEventListener","e","preventDefault","reset","visualizeSetState","edgeAttribute","nodeAttribute","updatedNodes","visualizeGraph","isStartNodeSelected","isEndNodeSelected","setTimeout","some","visualizeShortestPath","addEdge","tagName","isEdgeNotPresent","every","isNotCurrentNode","tempX2","tempY2","fromNodeId","toNode","toNodeId","fromNode","editEdge","editEdgeWeight","upgradedEdges","newEdges","upgradedOutgoingEdges","upgradedIncomingEdges","event","canMoveNode","moveNode","canDrawEdge","target","handleNodeEnd","removeEventListener","handleArrowMove","arrowX","clientX","getBoundingClientRect","left","arrowY","clientY","top","getAttribute","handleArrowEnd","pointerType","find","findToNodeForTouchBasedDevices","undefined","MessageBar","isMultiline","dismissButtonAriaLabel","fontWeight","fontSize","pathError","messageBarType","MessageBarType","error","ref","isNode","drawNode","nodeX","nodeY","newNode","addNode","bfsQueue","Set","lastVisitedEdge","front","neighbours","dfsStack","output","delete","size","deleteEdgeMode","deleteEdge","deleteNodeMode","deleteNode","mockArrow","Modal","main","minHeight","minWidth","height","scrollableContent","display","isOpen","TextField","fieldGroup","border","min","max","onKeyDown","keyCode","onChange","modalButton","Board","setOptions","setSelectedEdge","setSelectedAlgo","activateOption","option","updatedOptions","mapValues","board","controlPanel","nodeOptions","optionButtons","selectedButtonOption","disabled","icon","Dropdown","dropdownWrapper","selectedDropdownOption","placeholder","selectedKey","_event","visualizeControls","miscellaneous","visualizerProgress","ProgressIndicator","itemProgress","padding","graphContainer","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.10961be6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"Node_node__c-h_I\",\"directedEdge\":\"Node_directedEdge__3EpFJ\",\"edge\":\"Node_edge__1DJ6j\",\"visited\":\"Node_visited__3kUTj\",\"traversal\":\"Node_traversal__2YMmH\",\"arrowTraversal\":\"Node_arrowTraversal__3DD-U\",\"arrowShortestPath\":\"Node_arrowShortestPath__3Bc_G\",\"usedInTraversal\":\"Node_usedInTraversal__2EJLP\",\"edgeTraversal\":\"Node_edgeTraversal__E9lWz\",\"usedInShortestPath\":\"Node_usedInShortestPath__2Q1ev\",\"edgeShortestPath\":\"Node_edgeShortestPath__1kna7\",\"shortestPath\":\"Node_shortestPath__1J_oo\",\"pathfinding\":\"Node_pathfinding__PUHi4\",\"readyForVisualization\":\"Node_readyForVisualization__1V1ZZ\",\"startNode\":\"Node_startNode__3IMwB\",\"endNode\":\"Node_endNode__1HgAA\",\"deleteNodeMode\":\"Node_deleteNodeMode__1QrsV\",\"editEdgeMode\":\"Node_editEdgeMode__pcVZl\",\"undirectedEdge\":\"Node_undirectedEdge__2u5_C\",\"deleteEdgeMode\":\"Node_deleteEdgeMode__1CVZK\",\"nodeText\":\"Node_nodeText__3T0Pl\",\"edgeText\":\"Node_edgeText__GnGDm\",\"common\":\"Node_common__3jmzL\",\"disableEdge\":\"Node_disableEdge__2naBo\",\"arrow\":\"Node_arrow__29Jyp\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"board\":\"Board_board__1LD6i\",\"controlPanel\":\"Board_controlPanel__ikjex\",\"nodeOptions\":\"Board_nodeOptions__3suK0\",\"edgeOptions\":\"Board_edgeOptions__3BCKL\",\"miscellaneous\":\"Board_miscellaneous__1c86K\",\"visualizeControls\":\"Board_visualizeControls__2RCW5\",\"graphContainer\":\"Board_graphContainer__raIta\",\"icon\":\"Board_icon__QX-4A\",\"optionButtons\":\"Board_optionButtons__1p_H4\",\"dropdownWrapper\":\"Board_dropdownWrapper__1nTty\",\"selectedButtonOption\":\"Board_selectedButtonOption__3dZKx\",\"selectedDropdownOption\":\"Board_selectedDropdownOption__2Df5c\",\"visualizerProgress\":\"Board_visualizerProgress__dMqv6\",\"appIcon\":\"Board_appIcon__1usuq\",\"speedSlider\":\"Board_speedSlider__1DVSk\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"graph\":\"Graph_graph__13Cty\",\"mockEdge\":\"Graph_mockEdge__1BNhU\",\"mockArrow\":\"Graph_mockArrow__1q9gW\",\"modalButton\":\"Graph_modalButton__12uVe\",\"pathError\":\"Graph_pathError__fShfI\",\"traversal\":\"Graph_traversal__2Xn8A\",\"pathfinding\":\"Graph_pathfinding__2VF6D\"};","export const calculateCurve = (x1, y1, x2, y2) => {\r\n  var mpx = (x2 + x1) * 0.5;\r\n  var mpy = (y2 + y1) * 0.5;\r\n\r\n  // angle of perpendicular to line:\r\n  var theta = Math.atan2(y2 - y1, x2 - x1) - Math.PI / 2;\r\n\r\n  // distance of control point from mid-point of line:\r\n  var offset = 30;\r\n\r\n  // location of control point:\r\n  var c1x = mpx + offset * Math.cos(theta);\r\n  var c1y = mpy + offset * Math.sin(theta);\r\n  let directedPath = `M${x1} ${y1} Q${c1x} ${c1y} ${x2} ${y2}`;\r\n  return directedPath;\r\n};\r\nexport const calculateTextLoc = (x1, y1, x2, y2) => {\r\n  var mpx = (x2 + x1) * 0.5;\r\n  var mpy = (y2 + y1) * 0.5;\r\n\r\n  // angle of perpendicular to line:\r\n  var theta = Math.atan2(y2 - y1, x2 - x1) - Math.PI / 2;\r\n\r\n  // distance of control point from mid-point of line:\r\n  var offset = 30;\r\n\r\n  // location of control point:\r\n  var c1x = mpx + offset * Math.cos(theta);\r\n  var c1y = mpy + offset * Math.sin(theta);\r\n  return { c1x, c1y };\r\n};\r\n//calculates accurate x2,y2 for the edge to just intersect the node\r\nexport const calculateAccurateCoords = (x1, y1, x2, y2) => {\r\n  let distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n  let d2 = distance - 30;\r\n  let ratio = d2 / distance;\r\n  let dx = (x2 - x1) * ratio;\r\n  let dy = (y2 - y1) * ratio;\r\n  let tempX = x1 + dx;\r\n  let tempY = y1 + dy;\r\n  return { tempX, tempY };\r\n};\r\n//find the to Node for the edge drawn for touch based devices\r\nexport const findToNodeForTouchBasedDevices = (x, y, nodes) => {\r\n  const r = 30;\r\n  return nodes.find(node => doesPointLieOnCircle(x, y, r, node.x, node.y));\r\n};\r\n\r\n//test if point lies on the circle\r\nexport const doesPointLieOnCircle = (\r\n  centerX,\r\n  centerY,\r\n  radius,\r\n  pointX,\r\n  pointY\r\n) => {\r\n  const difference = Math.sqrt(\r\n    Math.pow(centerX - pointX, 2) + Math.pow(centerY - pointY, 2)\r\n  );\r\n  return difference <= radius;\r\n};\r\n","import React from \"react\";\r\nimport styles from \"./Node.module.css\";\r\nimport { calculateCurve, calculateTextLoc } from \"../../../assets/js/calc.js\";\r\nexport const Node = (props) => {\r\n  const {\r\n    node,\r\n    edges,\r\n    handleMove,\r\n    handleEdge,\r\n    // deleteNodeMode,\r\n    // deleteEdgeMode,\r\n    editEdgeMode,\r\n    readyForVisualization,\r\n    readyForMovement,\r\n    readyForEdge,\r\n    pathFindingNode,\r\n  } = props;\r\n  return (\r\n    <g className={styles.nodeGroup}>\r\n      <circle\r\n        onPointerDown={handleMove}\r\n        className={`${styles.node} ${\r\n          node.isVisited && styles.visited\r\n        } ${node.isInShortestPath && styles.shortestPath} ${\r\n          readyForVisualization && styles.readyForVisualization\r\n        } ${\r\n          pathFindingNode &&\r\n          pathFindingNode.startNodeId === node.id &&\r\n          styles.startNode\r\n        }\r\n         ${\r\n           pathFindingNode &&\r\n           pathFindingNode.endNodeId === node.id &&\r\n           styles.endNode\r\n         } `}\r\n        cx={node.x}\r\n        cy={node.y}\r\n        r={node.r}\r\n        id={node.id.toString()}\r\n      ></circle>\r\n      {edges &&\r\n        edges?.get(node.id)?.map((edge) => {\r\n          let directedPath = calculateCurve(edge.x1, edge.y1, edge.x2, edge.y2);\r\n          let undirectedPath = `M${edge.x1},${edge.y1} L${edge.x2},${edge.y2}`;\r\n          let textCoordDirected = calculateTextLoc(\r\n            edge.x1,\r\n            edge.y1,\r\n            edge.x2,\r\n            edge.y2\r\n          );\r\n          return (\r\n            <>\r\n              {edge.type === \"directed\" && (\r\n                <>\r\n                  <marker\r\n                    className={`${styles.arrow} ${\r\n                      edge.isUsedInTraversal && styles.arrowTraversal\r\n                    } ${edge.isUsedInShortestPath && styles.arrowShortestPath}`}\r\n                    id={`arrowhead${node.id}${edge.to}`}\r\n                    markerWidth=\"10\"\r\n                    markerHeight=\"7\"\r\n                    refX=\"8.7\"\r\n                    refY=\"3.5\"\r\n                    orient=\"auto\"\r\n                  >\r\n                    <polygon points=\"0 0, 10 3.5, 0 7\" />\r\n                  </marker>\r\n                  <path\r\n                    id={`${node.id}${edge.to}`}\r\n                    onClick={() => handleEdge(edge, node)}\r\n                    d={directedPath}\r\n                    className={`${styles.directedEdge} ${editEdgeMode && styles.editEdgeMode} ${\r\n                      (readyForVisualization ||\r\n                        readyForMovement ||\r\n                        readyForEdge) &&\r\n                      styles.disableEdge\r\n                    } ${edge.isUsedInTraversal && styles.usedInTraversal} ${\r\n                      edge.isUsedInShortestPath && styles.usedInShortestPath\r\n                    }`}\r\n                    markerEnd={`url(#arrowhead${node.id}${edge.to})`}\r\n                  >\r\n                    dsds\r\n                  </path>\r\n                  {edge.weight && (\r\n                    <text\r\n                      className={styles.edgeText}\r\n                      x={textCoordDirected.c1x}\r\n                      y={textCoordDirected.c1y + 7}\r\n                    >\r\n                      {edge.weight}\r\n                    </text>\r\n                  )}\r\n                </>\r\n              )}\r\n\r\n              {edge.type === \"undirected\" && (\r\n                <>\r\n                  <path\r\n                    d={undirectedPath}\r\n                    id={`${node.id}${edge.to}`}\r\n                    onClick={() => handleEdge(edge, node)}\r\n                    className={`${styles.undirectedEdge} ${editEdgeMode && styles.editEdgeMode}\r\n                    ${\r\n                      (readyForVisualization ||\r\n                        readyForMovement ||\r\n                        readyForEdge) &&\r\n                      styles.disableEdge\r\n                    }\r\n                    ${edge.isUsedInTraversal && styles.usedInTraversal}\r\n                    ${edge.isUsedInShortestPath && styles.usedInShortestPath}\r\n                    `}\r\n                  ></path>\r\n                  {edge.weight && (\r\n                    <text\r\n                      className={styles.edgeText}\r\n                      x={(edge.x1 + edge.nodeX2) / 2}\r\n                      y={(edge.y1 + edge.nodeY2) / 2 - 10}\r\n                    >\r\n                      {edge.weight}\r\n                    </text>\r\n                  )}\r\n                </>\r\n              )}\r\n            </>\r\n          );\r\n        })}\r\n      <text className={styles.nodeText} x={node.x} y={node.y + 5}>\r\n        {node.id}\r\n      </text>\r\n    </g>\r\n  );\r\n};\r\n","export class Queue {\r\n  constructor() {\r\n    this.queue = [];\r\n  }\r\n  push(item) {\r\n    this.queue.push(item);\r\n  }\r\n  front() {\r\n    return !this.isEmpty() ? this.queue[0] : null;\r\n  }\r\n  back() {\r\n    return !this.isEmpty() ? this.queue[this.queue.length - 1] : null;\r\n  }\r\n  pop() {\r\n    if (!this.isEmpty()) {\r\n      this.queue.shift();\r\n    }\r\n  }\r\n  isEmpty() {\r\n    return this.queue.length === 0;\r\n  }\r\n}\r\n","export class Stack {\r\n  constructor() {\r\n    this.stack = [];\r\n  }\r\n  push(item) {\r\n    this.stack.push(item);\r\n  }\r\n  top() {\r\n    return !this.isEmpty() ? this.stack[this.stack.length - 1] : null;\r\n  }\r\n  pop() {\r\n    if (!this.isEmpty()) {\r\n      this.stack.pop();\r\n    }\r\n  }\r\n  isEmpty() {\r\n    return this.stack.length === 0;\r\n  }\r\n}\r\n","/* eslint-disable no-unused-expressions */\r\n\r\nimport { Queue } from \"../data-structures/Queue\";\r\nimport { Stack } from \"../data-structures/Stack\";\r\n\r\nexport const bfs = (edges, startNodeId) => {\r\n  const bfsQueue = new Queue();\r\n  const visitedEdges = [];\r\n  const mockEdge = {\r\n    x1: NaN,\r\n    x2: NaN,\r\n    y1: NaN,\r\n    y2: NaN,\r\n    nodeX2: NaN,\r\n    nodeY2: NaN,\r\n    from: \"Infinity\",\r\n    to: startNodeId.toString(),\r\n    type: \"directed\",\r\n    weight: NaN,\r\n    isUsedInTraversal: false\r\n  };\r\n  const visitedSet = new Set();\r\n  bfsQueue.push(mockEdge);\r\n  let newEdges = new Map(edges);\r\n  while (!bfsQueue.isEmpty()) {\r\n    let lastVisitedEdge = bfsQueue.front();\r\n    let nodeId = parseInt(lastVisitedEdge.to);\r\n    bfsQueue.pop();\r\n    if (!visitedSet.has(nodeId)) {\r\n      visitedEdges.push({\r\n        ...mockEdge,\r\n        from: lastVisitedEdge.from,\r\n        to: lastVisitedEdge.to\r\n      });\r\n      const neighbours = findNeighbours(nodeId, newEdges, visitedSet);\r\n      neighbours?.forEach(id => {\r\n        bfsQueue.push({\r\n          ...mockEdge,\r\n          from: nodeId.toString(),\r\n          to: id.toString()\r\n        });\r\n      });\r\n    }\r\n  }\r\n  return visitedEdges;\r\n};\r\n\r\nexport const dfs = (edges, startNodeId) => {\r\n  let dfsStack = new Stack();\r\n  const mockEdge = {\r\n    x1: NaN,\r\n    x2: NaN,\r\n    y1: NaN,\r\n    y2: NaN,\r\n    nodeX2: NaN,\r\n    nodeY2: NaN,\r\n    from: \"Infinity\",\r\n    to: startNodeId.toString(),\r\n    type: \"directed\",\r\n    weight: NaN,\r\n    isUsedInTraversal: false\r\n  };\r\n  dfsStack.push(mockEdge);\r\n  const visitedSet = new Set();\r\n  const visitedEdges = [];\r\n  let newEdges = new Map(edges);\r\n  while (!dfsStack.isEmpty()) {\r\n    let lastVisitedEdge = dfsStack.top();\r\n    let nodeId = parseInt(lastVisitedEdge.to);\r\n    dfsStack.pop();\r\n    if (!visitedSet.has(parseInt(lastVisitedEdge.to))) {\r\n      visitedEdges.push({\r\n        ...mockEdge,\r\n        from: lastVisitedEdge.from,\r\n        to: lastVisitedEdge.to\r\n      });\r\n\r\n      const neighbours = findNeighbours(nodeId, newEdges, visitedSet);\r\n      neighbours?.forEach(id => {\r\n        dfsStack.push({\r\n          ...mockEdge,\r\n          from: nodeId.toString(),\r\n          to: id.toString()\r\n        });\r\n      });\r\n    }\r\n  }\r\n  return visitedEdges;\r\n};\r\n\r\nexport const dijkstra = (edges, startNodeId, endNodeId) => {\r\n  const mockEdge = {\r\n    x1: NaN,\r\n    x2: NaN,\r\n    y1: NaN,\r\n    y2: NaN,\r\n    nodeX2: NaN,\r\n    nodeY2: NaN,\r\n    from: \"Infinity\",\r\n    to: startNodeId.toString(),\r\n    type: \"directed\",\r\n    weight: NaN,\r\n    isUsedInTraversal: false\r\n  };\r\n  if (startNodeId === endNodeId)\r\n    return { shortestPath: [mockEdge], visitedEdges: [mockEdge] };\r\n  let newEdges = new Map(edges);\r\n  let distance = new Map();\r\n  let prev = new Map();\r\n  let unvisitedSet = new Set();\r\n  let visitedEdges = [];\r\n  distance.set(mockEdge, 0);\r\n  newEdges.forEach((edges, nodeId) => {\r\n    edges?.forEach(edge => {\r\n      distance.set(edge, Infinity);\r\n    });\r\n    unvisitedSet.add(nodeId);\r\n  });\r\n  let currentEdge = mockEdge;\r\n  let currentNodeId = parseInt(currentEdge.to);\r\n  visitedEdges.push(currentEdge);\r\n  unvisitedSet.delete(currentNodeId);\r\n  while (unvisitedSet.size !== 0) {\r\n    getUnvisitedNeighbours(currentEdge, newEdges, distance, unvisitedSet, prev);\r\n    currentEdge = getSmallestUnvisited(distance, unvisitedSet);\r\n    if (currentEdge === undefined || distance.get(currentEdge) === Infinity) {\r\n      return {\r\n        shortestPath: [],\r\n        visitedEdges: visitedEdges\r\n      };\r\n    }\r\n    currentNodeId = parseInt(currentEdge.to);\r\n    visitedEdges.push(currentEdge);\r\n    unvisitedSet.delete(currentNodeId);\r\n    if (currentNodeId === endNodeId) {\r\n      return {\r\n        shortestPath: backtrack(prev, startNodeId, endNodeId),\r\n        visitedEdges: visitedEdges\r\n      };\r\n    }\r\n  }\r\n};\r\nconst backtrack = (prev, startNodeId, endNodeId) => {\r\n  const mockEdge = {\r\n    x1: NaN,\r\n    x2: NaN,\r\n    y1: NaN,\r\n    y2: NaN,\r\n    nodeX2: NaN,\r\n    nodeY2: NaN,\r\n    from: \"Infinity\",\r\n    to: startNodeId.toString(),\r\n    type: \"directed\",\r\n    weight: NaN,\r\n    isUsedInTraversal: false\r\n  };\r\n  const visitedOrder = [];\r\n  const visitedEdges = [];\r\n  let currentNodeId = endNodeId;\r\n  visitedOrder.push(currentNodeId);\r\n  while (prev.has(currentNodeId)) {\r\n    currentNodeId = prev.get(currentNodeId);\r\n    visitedOrder.push(currentNodeId);\r\n  }\r\n  visitedOrder.reverse();\r\n  visitedEdges.push(mockEdge);\r\n  for (let i = 0; i < visitedOrder.length - 1; i++) {\r\n    visitedEdges.push({\r\n      ...mockEdge,\r\n      from: visitedOrder[i].toString(),\r\n      to: visitedOrder[i + 1].toString()\r\n    });\r\n  }\r\n  return visitedEdges;\r\n};\r\nconst getSmallestUnvisited = (distance, unvisitedSet) => {\r\n  let smallestUnvisited = [];\r\n  distance.forEach((_value, edge) => {\r\n    if (unvisitedSet.has(parseInt(edge.to))) {\r\n      smallestUnvisited.push(edge);\r\n    }\r\n  });\r\n  return smallestUnvisited.sort((a, b) => distance.get(a) - distance.get(b))[0];\r\n};\r\nconst getUnvisitedNeighbours = (\r\n  currentEdge,\r\n  edges,\r\n  distance,\r\n  unvisitedSet,\r\n  prev\r\n) => {\r\n  let currentNodeId = parseInt(currentEdge.to);\r\n  if (edges.get(currentNodeId)) {\r\n    edges.get(currentNodeId)?.forEach(edge => {\r\n      if (unvisitedSet.has(parseInt(edge.to))) {\r\n        let shouldCompare = true;\r\n        let newDistance = distance.get(currentEdge) + edge.weight;\r\n        distance.forEach((value, d_edge) => {\r\n          if (\r\n            edge.to === d_edge.to &&\r\n            value !== Infinity &&\r\n            value <= newDistance\r\n          ) {\r\n            shouldCompare = false;\r\n          }\r\n        });\r\n        if (shouldCompare && newDistance < distance.get(edge)) {\r\n          distance.set(edge, newDistance);\r\n          prev.set(parseInt(edge.to), currentNodeId);\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\nconst findNeighbours = (nodeId, edges, visitedSet) => {\r\n  if (!visitedSet.has(nodeId)) {\r\n    visitedSet.add(nodeId);\r\n    return edges.get(nodeId)?.map(edge => {\r\n      return parseInt(edge.to);\r\n    });\r\n  }\r\n  return [];\r\n};\r\n","import { DropdownMenuItemType } from \"@fluentui/react\";\r\nexport const edgeOptions = [\r\n  {\r\n    key: \"select\",\r\n    text: \"Select Edge\"\r\n  },\r\n  {\r\n    key: \"directed\",\r\n    text: \"Directed\"\r\n  },\r\n  {\r\n    key: \"undirected\",\r\n    text: \"Undirected\"\r\n  }\r\n];\r\nexport const algoOptions = [\r\n  {\r\n    key: \"select\",\r\n    text: \"Select Algorithm\"\r\n  },\r\n  { key: \"divider_1\", text: \"-\", itemType: DropdownMenuItemType.Divider },\r\n  {\r\n    key: \"traversal\",\r\n    text: \"Traversal\",\r\n    itemType: DropdownMenuItemType.Header\r\n  },\r\n  {\r\n    key: \"bfs\",\r\n    data: \"traversal\",\r\n    text: \"Breath First Search\"\r\n  },\r\n  {\r\n    key: \"dfs\",\r\n    data: \"traversal\",\r\n    text: \"Depth First Search\"\r\n  },\r\n  { key: \"divider_2\", text: \"-\", itemType: DropdownMenuItemType.Divider },\r\n  {\r\n    key: \"pathfinding\",\r\n    text: \"Pathfinding\",\r\n    itemType: DropdownMenuItemType.Header\r\n  },\r\n  {\r\n    key: \"dijkstra\",\r\n    data: \"pathfinding\",\r\n    text: \"Dijkstra\"\r\n  }\r\n];\r\n\r\nexport const algoMessages = {\r\n  traversal: {\r\n    bfs: {\r\n      info: \"Click on any node to begin the traversal.\"\r\n    },\r\n    dfs: {\r\n      info: \"Click on any node to begin the traversal.\"\r\n    }\r\n  },\r\n  pathfinding: {\r\n    dijkstra: {\r\n      info:\r\n        \"Select a starting node and ending node to visualize the pathfinding algorithm.\",\r\n      failure: \"Path is not possible for the given vertices.\"\r\n    }\r\n  }\r\n};\r\n","/* eslint-disable no-unused-expressions */\r\n /* jshint expr: true */\r\nimport React, { useState, useRef, useEffect, useCallback } from \"react\";\r\nimport { Node } from \"../Graph/Node/Node\";\r\nimport styles from \"./Graph.module.css\";\r\nimport {\r\n  calculateAccurateCoords,\r\n  findToNodeForTouchBasedDevices,\r\n} from \"../../assets/js/calc.js\";\r\nimport { Modal, TextField, MessageBar, MessageBarType } from \"@fluentui/react\";\r\nimport {\r\n  bfs,\r\n  dfs,\r\n  dijkstra,\r\n} from \"../../algorithms/algorithms.js\";\r\nimport { cloneDeep } from \"lodash\";\r\nimport { algoMessages } from \"../../assets/js/readOnly\";\r\n\r\nexport const Graph = (props) => {\r\n  const {\r\n    options,\r\n    selectedEdge,\r\n    selectedAlgo,\r\n    visualizationSpeed,\r\n    setVisualizingState,\r\n    setNodeSelection,\r\n    nodeSelection,\r\n    isVisualizing,\r\n  } = props;\r\n  const [nodes, setNodes] = useState([]);\r\n  const [edges, setEdges] = useState(\r\n    new Map()\r\n  );\r\n  const [isModalOpen, setModalState] = useState(false);\r\n  const [edge, setEdge] = useState(null);\r\n  const [pathFindingNode, setPathFindingNode] = useState(null);\r\n  const [isPathPossible, setPathPossible] = useState(true);\r\n  const [mockEdge, setMockEdge] = useState(null);\r\n  const currentNode = useRef();\r\n  const currentEdge = useRef();\r\n  const nodesTillNow = useRef(0);\r\n  const graph = useRef();\r\n  const isVisualizationDone = useRef(false);\r\n\r\n  const resetNodesAndEdgesState = useCallback(() => {\r\n    let updateNodes = nodes.map((node) => {\r\n      return { ...node, isInShortestPath: false, isVisited: false };\r\n    });\r\n    let updatedEdges = cloneDeep(edges);\r\n    updatedEdges.forEach((list, nodeId) => {\r\n      let newList = list?.map((edge) => {\r\n        return {\r\n          ...edge,\r\n          isUsedInTraversal: false,\r\n          isUsedInShortestPath: false,\r\n        };\r\n      });\r\n      updatedEdges.set(nodeId, newList);\r\n    });\r\n    setNodes(updateNodes);\r\n    setEdges(updatedEdges);\r\n    setPathFindingNode(null);\r\n    isVisualizationDone.current = false;\r\n  }, [nodes, edges]);\r\n\r\n  useEffect(() => {\r\n    graph.current.addEventListener(\"touchmove\", (e) => e.preventDefault());\r\n  }, []);\r\n  useEffect(() => {\r\n    //deletes the graph from the board.\r\n    if (options.reset) {\r\n      setNodes([]);\r\n      setEdges(new Map());\r\n      nodesTillNow.current = 0;\r\n      isVisualizationDone.current = false;\r\n    }\r\n  }, [options.reset]);\r\n\r\n  useEffect(() => {\r\n    //whenever the selected Algorithm changes, set pathfinding node to null.\r\n    setPathFindingNode(null);\r\n  }, [selectedAlgo]);\r\n\r\n  useEffect(() => {\r\n    //Whenever options change and the visualization is recently competed,reset the graph to its pre-visualized state.\r\n    if (isVisualizationDone.current) {\r\n      resetNodesAndEdgesState();\r\n    }\r\n  }, [options, resetNodesAndEdgesState]);\r\n\r\n  //add a new node to the graph\r\n  const addNode = (event) => {\r\n    const target = event.target;\r\n    let nodeX = event.clientX - target.getBoundingClientRect().left;\r\n    let nodeY = event.clientY - target.getBoundingClientRect().top;\r\n    nodesTillNow.current += 1;\r\n    let newNode = {\r\n      id: nodesTillNow.current,\r\n      x: nodeX,\r\n      y: nodeY,\r\n      r: 30,\r\n    };\r\n    edges.set(nodesTillNow.current, []);\r\n    setEdges(edges);\r\n    setNodes([...nodes, newNode]);\r\n  };\r\n\r\n  //handles the logic for setting nodes and edges state for visualization\r\n  const visualizeSetState = (\r\n    currentEdge,\r\n    edgeAttribute,\r\n    nodeAttribute\r\n  ) => {\r\n    edges.forEach((list) => {\r\n      list?.forEach((edge) => {\r\n        if (\r\n          edge.type === \"directed\" &&\r\n          edge.from === currentEdge.from &&\r\n          edge.to === currentEdge.to\r\n        )\r\n        {\r\n          edge[edgeAttribute] = true;\r\n        }\r\n        if (edge.type === \"undirected\") {\r\n          if (edge.from === currentEdge.from && edge.to === currentEdge.to) {\r\n            edge[edgeAttribute] = true;\r\n            edges.get(parseInt(currentEdge.to))?.forEach((edge) => {\r\n              if (edge.to === currentEdge.from) {\r\n                edge[edgeAttribute] = true;\r\n              }\r\n            });\r\n          }\r\n        }\r\n      });\r\n    });\r\n    setEdges(edges);\r\n    let updatedNodes = [...nodes];\r\n    updatedNodes.forEach((node) => {\r\n      if (node.id === parseInt(currentEdge.to)) {\r\n        node[nodeAttribute] = true;\r\n      }\r\n    });\r\n\r\n    setNodes(updatedNodes);\r\n  };\r\n\r\n  //visualize shortest path logic\r\n  const visualizeShortestPath = (shortestPath) => {\r\n    for (let i = 0; i <= shortestPath.length; i++) {\r\n      if (i === shortestPath.length) {\r\n        setTimeout(() => {\r\n          setVisualizingState(false);\r\n          setNodeSelection({\r\n            ...nodeSelection,\r\n            isStartNodeSelected: false,\r\n            isEndNodeSelected: false,\r\n          });\r\n          isVisualizationDone.current = true;\r\n        }, visualizationSpeed * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const currentEdge = shortestPath[i];\r\n        const isNodeIsInShortedPath = nodes.some((node) => {\r\n          if (node.id === parseInt(currentEdge.to)) {\r\n            return node.isInShortestPath === true;\r\n          }\r\n          return false;\r\n        });\r\n        if (!isNodeIsInShortedPath) {\r\n          visualizeSetState(\r\n            currentEdge,\r\n            \"isUsedInShortestPath\",\r\n            \"isInShortestPath\"\r\n          );\r\n        }\r\n      }, visualizationSpeed * i);\r\n    }\r\n  };\r\n\r\n  //visualize the visited nodes and shortestPath if applicable\r\n  const visualizeGraph = (\r\n    visitedEdges,\r\n    shortestPath\r\n  ) => {\r\n    setNodeSelection({\r\n      ...nodeSelection,\r\n      isStartNodeSelected: false,\r\n      isEndNodeSelected: false,\r\n    });\r\n    setVisualizingState(true);\r\n    for (let i = 0; i <= visitedEdges.length; i++) {\r\n      if (i === visitedEdges.length) {\r\n        setTimeout(() => {\r\n          setPathFindingNode(null);\r\n          if(shortestPath){\r\n          visualizeShortestPath(shortestPath);\r\n          }\r\n        }, visualizationSpeed * i);\r\n        setVisualizingState(false)\r\n        return;\r\n      }\r\n\r\n      setTimeout(() => {\r\n        const currentEdge= visitedEdges[i];\r\n        const isNodeTraversed = nodes.some((node) => {\r\n          if (node.id === parseInt(currentEdge.to)) {\r\n            return node.isVisited === true;\r\n          }\r\n          return false;\r\n        });\r\n        if (!isNodeTraversed) {\r\n          visualizeSetState(currentEdge, \"isUsedInTraversal\", \"isVisited\");\r\n        }\r\n      }, visualizationSpeed * i);\r\n    }\r\n  };\r\n\r\n  //common handler for adding new nodes,deleting existing nodes and selecting nodes for visualization\r\n  const handleSelect = (event) => {\r\n    const target = event.target;\r\n    const isNode = target.tagName === \"circle\";\r\n    if (options.drawNode && !isNode) {\r\n      addNode(event);\r\n    } else if (selectedAlgo?.data === \"traversal\" && isNode && !isVisualizing) {\r\n        const startNodeId = parseInt(target.id);\r\n        if (selectedAlgo?.key === \"bfs\") {\r\n          let visitedEdges = bfs(edges, startNodeId);\r\n          visualizeGraph(visitedEdges);\r\n        } else if (selectedAlgo?.key === \"dfs\") {\r\n          let visitedEdges = dfs(edges, startNodeId);\r\n          visualizeGraph(visitedEdges);\r\n        }\r\n    } else if (\r\n      selectedAlgo?.data === \"pathfinding\" &&\r\n      isNode &&\r\n      !isVisualizing\r\n    ) {\r\n      if (!pathFindingNode) {\r\n        setPathFindingNode({ startNodeId: parseInt(target.id), endNodeId: -1 });\r\n      } else {\r\n        const startNodeId = pathFindingNode.startNodeId;\r\n        const endNodeId = parseInt(target.id);\r\n        setPathFindingNode({ ...pathFindingNode, endNodeId });\r\n        let output = dijkstra(\r\n          edges,\r\n          startNodeId,\r\n          endNodeId\r\n        );\r\n        if (output?.shortestPath.length !== 0 && output?.visitedEdges) {\r\n          visualizeGraph(output.visitedEdges, output.shortestPath);\r\n        } else {\r\n          setPathPossible(false);\r\n          setVisualizingState(true);\r\n          setNodeSelection({\r\n            ...nodeSelection,\r\n            isStartNodeSelected: false,\r\n            isEndNodeSelected: false,\r\n          });\r\n          setTimeout(() => {\r\n            setPathPossible(true);\r\n            setVisualizingState(false);\r\n            setPathFindingNode(null);\r\n          }, 2500);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  //add a new edge between two nodes\r\n  const addEdge = (id, tagName, x, y) => {\r\n    if (currentEdge.current) {\r\n      let x1 = currentEdge.current.x1;\r\n      let y1 = currentEdge.current.y1;\r\n      let x2 = x;\r\n      let y2 = y;\r\n      let nodeX2 = x2;\r\n      let nodeY2 = y2;\r\n      currentEdge.current.to = id;\r\n      const isEdgeNotPresent =\r\n        edges?.get(parseInt(currentEdge.current.from))?.length !== 0\r\n          ? edges\r\n              ?.get(parseInt(currentEdge.current.from))\r\n              ?.every((edge) => edge.to !== currentEdge.current.to)\r\n          : true;\r\n      const isNotCurrentNode =\r\n        currentEdge.current.from !== currentEdge.current.to;\r\n      const isEdgePossible = isEdgeNotPresent && isNotCurrentNode;\r\n      if (isEdgePossible) {\r\n        if (selectedEdge?.key === \"directed\") {\r\n          let { tempX: tempX2, tempY: tempY2 } = calculateAccurateCoords(\r\n            x1,\r\n            y1,\r\n            x2,\r\n            y2\r\n          );\r\n          const fromNodeId = parseInt(currentEdge.current.from);\r\n          let { ...toNode } = currentEdge.current;\r\n          toNode.x2 = tempX2;\r\n          toNode.y2 = tempY2;\r\n          toNode.nodeX2 = nodeX2;\r\n          toNode.nodeY2 = nodeY2;\r\n          toNode.type = \"directed\";\r\n          edges?.get(fromNodeId)?.push(toNode);\r\n        } else if (selectedEdge?.key === \"undirected\") {\r\n          const fromNodeId = parseInt(currentEdge.current.from);\r\n          const toNodeId = parseInt(currentEdge.current.to);\r\n          const isUndirectedEdgeNotPossible =\r\n            edges\r\n              ?.get(fromNodeId)\r\n              ?.some((edge) => parseInt(edge.to) === toNodeId) ||\r\n            edges\r\n              ?.get(toNodeId)\r\n              ?.some((edge) => parseInt(edge.to) === fromNodeId);\r\n          if (!isUndirectedEdgeNotPossible) {\r\n            let { tempX: tempX2, tempY: tempY2 } = calculateAccurateCoords(\r\n              x1,\r\n              y1,\r\n              x2,\r\n              y2\r\n            );\r\n            let { ...toNode } = currentEdge.current;\r\n            toNode.x2 = tempX2;\r\n            toNode.y2 = tempY2;\r\n            toNode.nodeX2 = nodeX2;\r\n            toNode.nodeY2 = nodeY2;\r\n            toNode.type = \"undirected\";\r\n            edges?.get(fromNodeId)?.push(toNode);\r\n            let { tempX: tempX1, tempY: tempY1 } = calculateAccurateCoords(\r\n              x2,\r\n              y2,\r\n              x1,\r\n              y1\r\n            );\r\n            let fromNode = {\r\n              x1: x2,\r\n              y1: y2,\r\n              x2: tempX1,\r\n              y2: tempY1,\r\n              nodeX2: x1,\r\n              nodeY2: y1,\r\n              from: currentEdge.current.to,\r\n              to: currentEdge.current.from,\r\n              type: \"undirected\",\r\n              weight: currentEdge.current.weight,\r\n            };\r\n            edges?.get(toNodeId)?.push(fromNode);\r\n          }\r\n        }\r\n        setEdges(edges);\r\n      }\r\n    }\r\n  };\r\n\r\n  //common handler for deletion and edition of edges.\r\n  const handleEdge = (edge, fromNode) => {\r\n    if (options.editEdge) {\r\n      editEdge(edge, fromNode);\r\n    }\r\n  };\r\n\r\n\r\n  //function called when edit Edge button is clicked.\r\n  const editEdge = (edge, fromNode) => {\r\n    currentNode.current = { ...fromNode };\r\n    setEdge(edge);\r\n    setModalState(true);\r\n  };\r\n\r\n  //function that actually contains the logic for setting weight of selected edge.\r\n  const editEdgeWeight = () => {\r\n    let currentEdge = { ...edge };\r\n    if (edge?.type === \"directed\") {\r\n      let upgradedEdges = edges\r\n        ?.get(currentNode.current.id)\r\n        ?.map((edge) => {\r\n          if (edge.to === currentEdge.to) {\r\n            return { ...edge, weight: currentEdge.weight };\r\n          }\r\n          return edge;\r\n        });\r\n      let newEdges = new Map(edges);\r\n      newEdges.set(currentNode.current.id, upgradedEdges);\r\n      setEdges(newEdges);\r\n    } else if (edge?.type === \"undirected\") {\r\n      let upgradedOutgoingEdges = edges\r\n        ?.get(currentNode.current.id)\r\n        ?.map((edge) => {\r\n          if (edge.to === currentEdge.to) {\r\n            return { ...edge, weight: currentEdge.weight };\r\n          }\r\n          return edge;\r\n        });\r\n      let upgradedIncomingEdges = edges\r\n        ?.get(parseInt(currentEdge.to))\r\n        ?.map((edge) => {\r\n          if (edge.to === currentNode.current.id.toString()) {\r\n            return { ...edge, weight: currentEdge.weight };\r\n          }\r\n          return edge;\r\n        });\r\n      let newEdges = new Map(edges);\r\n      newEdges.set(currentNode.current.id, upgradedOutgoingEdges);\r\n      newEdges.set(parseInt(currentEdge.to), upgradedIncomingEdges);\r\n      setEdges(newEdges);\r\n    }\r\n    setModalState(false);\r\n  };\r\n\r\n  //common handler for movement related operations - moving node and drawing edges.\r\n  const handleMove = (event) => {\r\n    let canMoveNode = options.moveNode;\r\n    let canDrawEdge =\r\n      selectedEdge?.key &&\r\n      (selectedEdge.key === \"directed\" || selectedEdge.key === \"undirected\");\r\n    if (canMoveNode) {\r\n      currentNode.current = event.target;\r\n\r\n      //function triggered to remove mouse event listeners.\r\n      const handleNodeEnd = () => {\r\n        graph.current.removeEventListener(\"pointerup\", handleNodeEnd);\r\n      };\r\n      graph.current.addEventListener(\"pointerup\", handleNodeEnd);\r\n    } else if (canDrawEdge) {\r\n      currentNode.current = event.target;\r\n      //logic for drawing of edges.\r\n      const handleArrowMove = (event) => {\r\n        let arrowX = event.clientX - graph.current.getBoundingClientRect().left;\r\n        let arrowY = event.clientY - graph.current.getBoundingClientRect().top;\r\n        currentEdge.current = {\r\n          x1: parseInt(currentNode.current.getAttribute(\"cx\")),\r\n          y1: parseInt(currentNode.current.getAttribute(\"cy\")),\r\n          x2: arrowX,\r\n          y2: arrowY,\r\n          from: currentNode.current.id,\r\n          to: \"\",\r\n          weight: 0,\r\n        };\r\n        setMockEdge(currentEdge.current);\r\n      };\r\n      //function triggered to remove mouse event listeners.\r\n      const handleArrowEnd = (event) => {\r\n        const isTouchEvent = event.pointerType === \"touch\";\r\n        if (isTouchEvent) {\r\n          const node = findToNodeForTouchBasedDevices(\r\n            event.clientX - graph.current.getBoundingClientRect().left,\r\n            event.clientY - graph.current.getBoundingClientRect().top,\r\n            nodes\r\n          );\r\n          if (node) {\r\n            addEdge(node.id.toString(), \"circle\", node.x, node.y);\r\n          }\r\n        } else {\r\n          const target = event.target;\r\n          const isNode = target.tagName === \"circle\";\r\n          if (isNode) {\r\n            const x = parseInt(target.getAttribute(\"cx\"));\r\n            const y = parseInt(target.getAttribute(\"cy\"));\r\n            addEdge(target.id, \"circle\", x, y);\r\n          }\r\n        }\r\n        setMockEdge(null);\r\n        currentEdge.current = undefined;\r\n        graph.current.removeEventListener(\"pointermove\", handleArrowMove);\r\n        graph.current.removeEventListener(\"pointerup\", handleArrowEnd);\r\n      };\r\n      graph.current.addEventListener(\"pointermove\", handleArrowMove);\r\n      graph.current.addEventListener(\"pointerup\", handleArrowEnd);\r\n    }\r\n  };\r\n  return (\r\n    <>\r\n      {selectedAlgo?.data === \"traversal\" &&\r\n        (\r\n          <MessageBar\r\n            className={styles.traversal}\r\n            isMultiline={false}\r\n            dismissButtonAriaLabel=\"Close\"\r\n            styles={{ text: { fontWeight: \"bold\", fontSize: \"14px\" } }}\r\n          >\r\n            {algoMessages[selectedAlgo?.data][selectedAlgo.key][\"info\"]}\r\n          </MessageBar>\r\n        )\r\n      }\r\n      {selectedAlgo?.data === \"pathfinding\" &&\r\n        (isPathPossible ? (\r\n          <MessageBar\r\n            className={styles.pathfinding}\r\n            isMultiline={false}\r\n            dismissButtonAriaLabel=\"Close\"\r\n            styles={{ text: { fontWeight: \"bold\", fontSize: \"14px\" } }}\r\n          >\r\n            {algoMessages[selectedAlgo?.data][selectedAlgo.key][\"info\"]}\r\n          </MessageBar>\r\n        ) : (\r\n          <MessageBar\r\n            className={styles.pathError}\r\n            messageBarType={MessageBarType.error}\r\n            isMultiline={false}\r\n            dismissButtonAriaLabel=\"Close\"\r\n            styles={{ text: { fontWeight: \"bold\", fontSize: \"14px\" } }}\r\n          >\r\n            {algoMessages[selectedAlgo?.data][selectedAlgo.key][\"failure\"]}\r\n          </MessageBar>\r\n        ))}\r\n      <svg ref={graph} className={styles.graph} onClick={handleSelect}>\r\n        {nodes.map((node) => (\r\n          <Node\r\n            handleEdge={handleEdge}\r\n            handleMove={handleMove}\r\n            key={node.id}\r\n            node={node}\r\n            edges={edges}\r\n            deleteEdgeMode={options.deleteEdge}\r\n            deleteNodeMode={options.deleteNode}\r\n            editEdgeMode={options.editEdge}\r\n            readyForVisualization={nodeSelection.isStartNodeSelected}\r\n            readyForMovement={options.moveNode}\r\n            readyForEdge={selectedEdge?.key !== \"select\"}\r\n            pathFindingNode={pathFindingNode}\r\n          />\r\n        ))}\r\n        {mockEdge && (\r\n          <>\r\n            {selectedEdge?.key === \"directed\" && (\r\n              <marker\r\n                className={styles.mockArrow}\r\n                id=\"mockArrowHead\"\r\n                markerWidth=\"10\"\r\n                markerHeight=\"7\"\r\n                refX=\"0\"\r\n                refY=\"3.5\"\r\n                orient=\"auto\"\r\n              >\r\n                <polygon points=\"0 0, 10 3.5, 0 7\" />\r\n              </marker>\r\n            )}\r\n            <line\r\n              className={styles.mockEdge}\r\n              x1={mockEdge.x1}\r\n              y1={mockEdge.y1}\r\n              x2={mockEdge.x2}\r\n              y2={mockEdge.y2}\r\n              markerEnd=\"url(#mockArrowHead)\"\r\n            ></line>\r\n          </>\r\n        )}\r\n      </svg>\r\n      <Modal\r\n        styles={{\r\n          main: { minHeight: \"0px\", minWidth: \"0px\", height: \"31px\" },\r\n          scrollableContent: { display: \"flex\" },\r\n        }}\r\n        isOpen={isModalOpen}\r\n      >\r\n        {edge && edge.weight !== null && (\r\n          <TextField\r\n            styles={{ fieldGroup: { border: \"none\" } }}\r\n            type=\"number\"\r\n            min={0}\r\n            max={500}\r\n            value={edge.weight.toString()}\r\n            onKeyDown={(e) => {\r\n              if (e.keyCode === 13) {\r\n                editEdgeWeight();\r\n              }\r\n            }}\r\n            onChange={(e) => {\r\n              parseInt(e.target.value) >= 0 && parseInt(e.target.value) <= 500\r\n                ? setEdge({ ...edge, weight: parseInt(e.target.value) })\r\n                : e.preventDefault();\r\n            }}\r\n          />\r\n        )}\r\n\r\n        <button className={styles.modalButton} onClick={editEdgeWeight}>\r\n          Set Weight\r\n        </button>\r\n      </Modal>\r\n    </>\r\n  );\r\n}\r\n","import React, { useState, useEffect } from \"react\";\r\nimport { Graph } from \"../Graph/Graph\";\r\nimport styles from \"./Board.module.css\";\r\nimport { mapValues } from \"lodash\";\r\nimport {\r\n  Dropdown,\r\n  ProgressIndicator,\r\n} from \"@fluentui/react\";\r\nimport { edgeOptions, algoOptions } from \"../../assets/js/readOnly\";\r\n\r\nexport default function Board () {\r\n  const [options, setOptions] = useState({\r\n    drawNode: true,\r\n    reset: false,\r\n    editEdge: false,\r\n  });\r\n  const [nodeSelection, setNodeSelection] = useState({\r\n    isStartNodeSelected: false,\r\n    isEndNodeSelected: false,\r\n  });\r\n  const [selectedEdge, setSelectedEdge] = useState(\r\n    edgeOptions[0]\r\n  );\r\n  const [selectedAlgo, setSelectedAlgo] = useState(\r\n    algoOptions[0]\r\n  );\r\n  const [isVisualizing, setVisualizingState] = useState(false);\r\n  const visualizationSpeed = 1000;\r\n\r\n  useEffect(() => {\r\n    if (!isVisualizing) {\r\n      setSelectedAlgo({ key: \"select\", text: \"Select Algorithm\" });\r\n    }\r\n  }, [isVisualizing]);\r\n\r\n  //Activates the desired option from control panel.\r\n  const activateOption = (option) => {\r\n    const updatedOptions = mapValues(options, (_value, key) =>\r\n      key === option ? true : false\r\n    );\r\n    setSelectedEdge({ key: \"select\", text: \"Select Edge\" });\r\n    setSelectedAlgo({ key: \"select\", text: \"Select Algorithm\" });\r\n    setNodeSelection({\r\n      ...nodeSelection,\r\n      isStartNodeSelected: false,\r\n      isEndNodeSelected: false,\r\n    });\r\n    setOptions(updatedOptions);\r\n  };\r\n\r\n  //handles the selection of edge options and corresponding toggles for other options in control panel.\r\n  const handleEdgeOptions = (_event,option) => {\r\n    const updatedOptions = mapValues(options, () => false);\r\n    setOptions(updatedOptions);\r\n    setSelectedAlgo({ key: \"select\", text: \"Select Algorithm\" });\r\n    setSelectedEdge(option);\r\n  };\r\n\r\n  //handles the selection of algo options and corresponding toggles for other options in control panel.\r\n  const handleAlgoOptions = (_event,option) => {\r\n    setSelectedAlgo(option);\r\n    setSelectedEdge({ key: \"select\", text: \"Select Edge\" });\r\n    if (option?.key === \"select\") {\r\n      const updatedOptions = mapValues(options, () => false);\r\n      setOptions(updatedOptions);\r\n    } else if (option?.data === \"traversal\") {\r\n      setNodeSelection({ ...nodeSelection, isStartNodeSelected: true });\r\n      const updatedOptions = mapValues(options, () => false);\r\n      setOptions(updatedOptions);\r\n    } else if (option?.data === \"pathfinding\") {\r\n      setNodeSelection({\r\n        ...nodeSelection,\r\n        isStartNodeSelected: true,\r\n        isEndNodeSelected: true,\r\n      });\r\n      const updatedOptions = mapValues(options, () => false);\r\n      setOptions(updatedOptions);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <div className={styles.board}>\r\n        <div\r\n          className={styles.controlPanel}\r\n        >\r\n          <div className={styles.nodeOptions}>\r\n            <button\r\n              className={`${styles.optionButtons} ${\r\n                options.drawNode && styles.selectedButtonOption\r\n              }`}\r\n              onClick={() => activateOption(\"drawNode\")}\r\n              disabled={isVisualizing}\r\n            >\r\n              <i className={`${styles.icon} fas fa-circle`}></i>\r\n              Draw Node\r\n            </button>\r\n          </div>\r\n          <div className={styles.edgeOptions}>\r\n            <Dropdown\r\n              className={`${styles.dropdownWrapper} ${\r\n                selectedEdge?.key !== \"select\" && styles.selectedDropdownOption\r\n              }`}\r\n              options={edgeOptions}\r\n              placeholder=\"Select Edge\"\r\n              selectedKey={selectedEdge && selectedEdge.key}\r\n              onChange={handleEdgeOptions}\r\n              disabled={isVisualizing}\r\n            />\r\n            <button\r\n              className={`${styles.optionButtons} ${\r\n                options.editEdge && styles.selectedButtonOption\r\n              }`}\r\n              onClick={() => activateOption(\"editEdge\")}\r\n              disabled={isVisualizing}\r\n            >\r\n              <i className={`${styles.icon} fas fa-pen`}></i>\r\n              Edit Edge\r\n            </button>\r\n          </div>\r\n          <div className={styles.visualizeControls}>\r\n            <Dropdown\r\n              className={`${styles.dropdownWrapper} ${\r\n                selectedAlgo?.key !== \"select\" && styles.selectedDropdownOption\r\n              }`}\r\n              options={algoOptions}\r\n              placeholder=\"Select Algorithm\"\r\n              selectedKey={selectedAlgo && selectedAlgo.key}\r\n              onChange={handleAlgoOptions}\r\n              disabled={isVisualizing}\r\n            />\r\n          </div>\r\n          <div className={styles.miscellaneous}>\r\n            <button\r\n              className={`${styles.optionButtons} ${\r\n                options.reset && styles.selectedButtonOption\r\n              }`}\r\n              onClick={() => activateOption(\"reset\")}\r\n              disabled={isVisualizing}\r\n            >\r\n              <i className={`${styles.icon} fas fa-undo-alt`}></i>\r\n              Reset\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        <div className={styles.visualizerProgress}>\r\n          {isVisualizing ? (\r\n            <ProgressIndicator styles={{ itemProgress: { padding: \"0\" } }} />\r\n          ) : (\r\n            <hr />\r\n          )}\r\n        </div>\r\n        <div className={styles.graphContainer}>\r\n          <Graph\r\n            options={options}\r\n            selectedAlgo={selectedAlgo}\r\n            selectedEdge={selectedEdge}\r\n            visualizationSpeed={visualizationSpeed}\r\n            setVisualizingState={setVisualizingState}\r\n            isVisualizing={isVisualizing}\r\n            nodeSelection={nodeSelection}\r\n            setNodeSelection={setNodeSelection}\r\n          />\r\n        </div>\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport Board from \"./components/Board/Board\"\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Board/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\n\r\nReactDOM.render(\r\n  <div>\r\n    <App />\r\n  </div>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}